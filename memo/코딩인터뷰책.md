##### 1.1 변수(Variables)

##### 1.2 자료형(Data Types)

**시스템 정의 자료형** : int, float, char, double 등
**사용자 정의 자료형** : C/C++의 구조체와 Java의 클래스

```c
struct newType {
    int data1;
    float data2;
};
```

위 코드가 시스템 정의 자료형들을 조합하여 "newType"이라는 이름의 새로운 사용자 정의 자료형이다 

<hr>

##### 1.3 자료 구조(Data Structure)

**자료 구조** : 컴퓨터 내에서 유용하게 사용되도록 데이터를 저장하고 구조화하는 특별한 형태

**일반적 자료 구조 유형** : 배열, 연결 리스트, 스택, 큐, 트리, 그래프 등
**선형 자료구조** : 선형 자료 구조의 구성 요소들은 순차적으로 접근되지만, 모든 요소들이 반드시 순차적으로 저장되지는 않는다. ex) 연결 리스트, 스택, 큐
**비선형 자료구조** : 자료 구조의 구성 요소들이 비순차적인 순서로 저장되고 접근된다. ex) 트리, 그래프

<hr>

##### 1.4 추상 자료형(Abstract Data Types)

**추상 자료형** : 자료 구조와 연산을 결합한 형태, 추상 자료형은 **데이터 선언**, **연산자 선언**으로 구성

<hr>

##### 1.5 메모리와 변수(Memory and Variables)

메모리는 바이트의 배열처럼 다룰 수 있다. 
각각의 위치는 주소로 식별된다. 
보통 0번 주소는 유효한 메모리 주소가 아니다.

어떤 위치를 읽거나 쓰기 위해 CPU는 메모리 제어기(memory controller)에 그 위치를  전달하여 접근.

1. int x; x 라는 int형 변수를 선언
2. 컴파일러는 연속된 메모리 블록을 할당, 이 크기는 변수의 크기에 달려 있다.
3. 컴파일러는 변수 이름 x와 할당된 첫 번째 바이트의 주소를 연결짓는 내부적인 태그를 유지한다.(symbol table)
4. x = 10; 컴파일러는 x라는 변수가 어디에 위치하는지 알아내고 해당 위치에 10이라는 값을 사용.

**Size of a Variables** : Sizeof 연산자는 변수의 크기(메모리)를 알아내는데 사용된다.
Sizeof(x)가 4를 return 한다면 integer는 메모리에서 4개의 연속된 byte가 필요하다는 것.
x의 주소가 2000이라고 한다면 실제 x에 의해서 사용되는 메모리 주소는 2000, 2001, 2002, 2003이다.

**Address of a Variables** : C언어에서 참조 연산자(&)를 사용하여 변수의 주소를 얻을 수 있다.

<hr>

##### 1.6 포인터(Pointers)

**포인터** : 다른 변수의 주소를 보관할 수 있는 변수이다.

포인터의 선언(Declare of Pointers) : 포인터가 가르킬 변수의 자료형을 명시해야 한다.
주소를 저장하고자 하는 변수에 대한 자료형이 필요.

```c
int *ptr;
float *ptr1;
unsigned int *ptr2;
void *ptr3;
```

ptr은 int형 변수를 가리킬 수 있는 포인터, ptr1은 float형 가르킬 수 있는 포인터, ptr3는 형을 지정하지 않아 무엇이든 가르킬 수 있는 포인터. 이를 void 형 포인터라고 한다.

```c
int x = 10;
int *ptr = &x;
*ptr = 25;
```

1. x라는 이름의 int형 변수를 선언하고 10으로 값을 초기화 해준다.
2. ptr이 가진 값은 변수 x의 주소 값이다.
3. 포인터 ptr이 가르키는 주소에 들어있는 값을 25로 변경
4. 변수 x의 값이 25로 변경되어 출력
5. 포인터 ptr이 변수 x의 주소 값을 가지고 있다.
6. 포인터 ptr이 가리키는 주소에 든 값을 변경하면 변수 x의 값이 변경된다. 

**void형 포인터** : 모든 형을 가리킬 수 있지만 한가지 제약이 있다. 간접 참조를 할 수 없다.
다른 자료형들이 차지하는 메모리의 크기가 서로 다르기 때문.
32bit 컴퓨터에서 int 형은 4byte, short형은 2byte 차지한다.
컴파일러는 가리키는 주소에서 전체 값을 읽어 들이기 위해 얼마나 많은 바이트를 읽어야 할지 알아야 하지만 void형 포인터는 못한다.

```c
#include <stdio.h>

int main() {

	char* cptr = (char*)2;
	printf("cptr before : %p\n", cptr);
	cptr++;
	printf("cptr after : %p", cptr);
}
```

cptr이라는 포인터를 선언, 2라는 주소를 할당한 후 출력하면 00000002가 나오고 포인터를 증가시킨  후 출력해보면 00000003이 나오게 된다.

```c
#include <stdio.h>

int main() {

	int *iptr = (int*)2;
	printf("iptr before : %p\n", iptr);
	iptr++;
	printf("iptr after : %p", iptr);
}
```

코드는 위와 같지만 결과값은 다르다. 첫 결과는 00000002, 두번째 결과는 00000006이 나오게 된다. 
sizeof 변수때문에 값이 다르게 된다. int형의 길이는 4byte. 주소 2에 int형 변수가 있다면 메모리 주소 2, 3, 4,5 를 차지하여 그 다음값인 6이 iptr++ 의 값이 된다. 

위에 cptr은 char형이고 char 자료형은 1byte이다. cptr++을 해도 증가값은 1개가 되므로 2 다음 3 값이 나오게 된다. 

**함수 포인터(Function Pointers)** : 데이터 및 실행 코드는 메모리에 저장된다. 함수의 주소 또한 얻을 수 있다. 

<hr>

##### 1.7 파라미터 전달 기법(Parameter Passing Techniques) 

**실제 변수와 형식 변수(Actual and Formal Parameters)** : 

함수 B()가 다른 함수 A()에 의해 호출된다고 가정. 
A는 **호출자 함수(caller function)**, 호출된 함수 B는 **피호출자 함수(callee function)**라고 한다.
A가 B에게 보내는 인자를 **실제 매개 변수(actual argument)**라고 한다. 
B함수의 파라미터는 **형식 매개 변수(formal argument)**라고 한다. 

**파라미터 전달의 의미(Semantics of Parameter Passing)** : 

**입력(IN)** : 호출자에서 피호출자에게 정보를 전달한다. 형식 매개 변수는 실제 매개 변수에서 값을 취하지만, 실제 매개 변수에게 값을 전달할 수는 없다.
**출력(OUT)** : 피호출자가 호줄자 내에 값을 쓸 수 있다. 형식 매개 변수는 피호출자의 실제 매개 변수를 통해 값을 전달할 수 있지만 실제 매개 변수를 통해 값을 얻을 수 없다. 
**입/출력** : 호출자는 피호출자에게 피호출자에 의한 갱신이 가능한 변수의 값을 전달. 형식 매개 변수는 실제 매개 변수에서 값을 획득하거나 전달할 수 있다. 

```c
#include <stdio.h>

void func(int a, int b) {
    b = 5;
    a += b;
    printf("In func : a = %d b = %d\n", a, b);
}
int main(void) {
        int x = 5, y = 7;
        func(x, y);
        printf("In main :  x = %d y = %d\n", x, y);
        return 0;
}

```

func의 값은 a = 10, b = 5 main의 값은 x = 5, y = 7이다. 
main 함수는 func 함수에 5, 7 값을 전달한다. 

<hr>

##### 1.8 바인딩(Binding )

최상위 수준에서 바인등은 이름(변수, 배열, 라벨, 절차 등의 명칭)을 메모리 주소, 데이터 형 또는 실제 값에 연결하는 작업 이다. 

**바인딩 시점(Binding Times)** : 프로그램의 생명주기를 기준으로, 바인딩은 다양한 시점에서 발생할 수 있다.

1. 언어 설계시 : 연산자와 연산의 바인딩
2. 언어 구현시 : 데이터 유형과 데이터 유형이 가질 수 있는 바인딩
3. 프로그램 작성 시 : 알고리즘, 데이터 구조, 모듈 이름에 대한 바인딩
4. 컴파일 시 : 변수와 데이터 유형을 바인딩 (대부분의 바인딩은 여기서)
5. 링크 시 : 메모리 내의 프로그램 전체 레이아웃
6. 로드 시 : 물리적 주소 선택
7. 실행 시 : 변수에 메모리에 위치한 값을 바인딩 

**정적 바인딩(Static Binding)** : 프로그램 실행 이전에 이루어 지며 실행중에 변경되지 않는다.
**동적 바인딩(Dynamic Binding)** : 프로그램이 실행되는 동안 발생하거나 변경된다.

<hr>

##### 1.9 스코프(Scope)

**스코프** : 변수의 바인딩 변경이 없거나 최소한 변수의 재선언이 허락되지 않는 최대 범위를 말한다.
**정적 스코프(Static Scope)** : 프로그램의 물리적인 구조로 정의되고, 스코프의 결정은 컴파일어에 의해 수행된다. 프로그램 텍스트를 검토하여 바인딩한다.
**동적 스코프(Dynamic Scope)** : 일반적으로 Interpreted(해석) 언어에서 사용한다. 자료형에 대한 결정이 항상 가능하지는 않아서 컴파일 시 자료형을 체크할 수 없다. 



