##### 1.1 변수(Variables)

##### 1.2 자료형(Data Types)

**시스템 정의 자료형** : int, float, char, double 등
**사용자 정의 자료형** : C/C++의 구조체와 Java의 클래스

```c
struct newType {
    int data1;
    float data2;
};
```

위 코드가 시스템 정의 자료형들을 조합하여 "newType"이라는 이름의 새로운 사용자 정의 자료형이다 

<hr>

##### 1.3 자료 구조(Data Structure)

**자료 구조** : 컴퓨터 내에서 유용하게 사용되도록 데이터를 저장하고 구조화하는 특별한 형태

**일반적 자료 구조 유형** : 배열, 연결 리스트, 스택, 큐, 트리, 그래프 등
**선형 자료구조** : 선형 자료 구조의 구성 요소들은 순차적으로 접근되지만, 모든 요소들이 반드시 순차적으로 저장되지는 않는다. ex) 연결 리스트, 스택, 큐
**비선형 자료구조** : 자료 구조의 구성 요소들이 비순차적인 순서로 저장되고 접근된다. ex) 트리, 그래프

<hr>

##### 1.4 추상 자료형(Abstract Data Types)

**추상 자료형** : 자료 구조와 연산을 결합한 형태, 추상 자료형은 **데이터 선언**, **연산자 선언**으로 구성

<hr>

##### 1.5 메모리와 변수(Memory and Variables)

메모리는 바이트의 배열처럼 다룰 수 있다. 
각각의 위치는 주소로 식별된다. 
보통 0번 주소는 유효한 메모리 주소가 아니다.

어떤 위치를 읽거나 쓰기 위해 CPU는 메모리 제어기(memory controller)에 그 위치를  전달하여 접근.

1. int x; x 라는 int형 변수를 선언
2. 컴파일러는 연속된 메모리 블록을 할당, 이 크기는 변수의 크기에 달려 있다.
3. 컴파일러는 변수 이름 x와 할당된 첫 번째 바이트의 주소를 연결짓는 내부적인 태그를 유지한다.(symbol table)
4. x = 10; 컴파일러는 x라는 변수가 어디에 위치하는지 알아내고 해당 위치에 10이라는 값을 사용.

**Size of a Variables** : Sizeof 연산자는 변수의 크기(메모리)를 알아내는데 사용된다.
Sizeof(x)가 4를 return 한다면 integer는 메모리에서 4개의 연속된 byte가 필요하다는 것.
x의 주소가 2000이라고 한다면 실제 x에 의해서 사용되는 메모리 주소는 2000, 2001, 2002, 2003이다.

**Address of a Variables** : C언어에서 참조 연산자(&)를 사용하여 변수의 주소를 얻을 수 있다.

<hr>

##### 1.6 포인터(Pointers)

**포인터** : 다른 변수의 주소를 보관할 수 있는 변수이다.

포인터의 선언(Declare of Pointers) : 포인터가 가르킬 변수의 자료형을 명시해야 한다.
주소를 저장하고자 하는 변수에 대한 자료형이 필요.

```c
int *ptr;
float *ptr1;
unsigned int *ptr2;
void *ptr3;
```

ptr은 int형 변수를 가리킬 수 있는 포인터, ptr1은 float형 가르킬 수 있는 포인터, ptr3는 형을 지정하지 않아 무엇이든 가르킬 수 있는 포인터. 이를 void 형 포인터라고 한다.

```c
int x = 10;
int *ptr = &x;
*ptr = 25;
```

1. x라는 이름의 int형 변수를 선언하고 10으로 값을 초기화 해준다.
2. ptr이 가진 값은 변수 x의 주소 값이다.
3. 포인터 ptr이 가르키는 주소에 들어있는 값을 25로 변경
4. 변수 x의 값이 25로 변경되어 출력
5. 포인터 ptr이 변수 x의 주소 값을 가지고 있다.
6. 포인터 ptr이 가리키는 주소에 든 값을 변경하면 변수 x의 값이 변경된다. 

**void형 포인터** : 모든 형을 가리킬 수 있지만 한가지 제약이 있다. 간접 참조를 할 수 없다.
다른 자료형들이 차지하는 메모리의 크기가 서로 다르기 때문.
32bit 컴퓨터에서 int 형은 4byte, short형은 2byte 차지한다.
컴파일러는 가리키는 주소에서 전체 값을 읽어 들이기 위해 얼마나 많은 바이트를 읽어야 할지 알아야 하지만 void형 포인터는 못한다.

```c
#include <stdio.h>

int main() {

	char* cptr = (char*)2;
	printf("cptr before : %p\n", cptr);
	cptr++;
	printf("cptr after : %p", cptr);
}
```

cptr이라는 포인터를 선언, 2라는 주소를 할당한 후 출력하면 00000002가 나오고 포인터를 증가시킨  후 출력해보면 00000003이 나오게 된다.

```c
#include <stdio.h>

int main() {

	int *iptr = (int*)2;
	printf("iptr before : %p\n", iptr);
	iptr++;
	printf("iptr after : %p", iptr);
}
```

코드는 위와 같지만 결과값은 다르다. 첫 결과는 00000002, 두번째 결과는 00000006이 나오게 된다. 